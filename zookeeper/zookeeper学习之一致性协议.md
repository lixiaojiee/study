# 一、两阶段提交（2PC）

两阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事物处理过程中能够保持原子性和一致性而设计的一种算法

两阶段提交是将事物的提交过程分成了两个阶段来进行处理，其执行流程如下：

**阶段一：提交事物请求**

1、事物询问

协调者向所有的事物参与者发送事物内容，询问是否可以执行事物提交操作，并开始等待各参与者的响应

2、执行事物

各参与者节点执行事物操作，并将Undo和Redo信息记入到事物日志中

3、各参与者向协调者反馈事物询问的响应

如果参与者成功执行了事物操作，那么就反馈给协调者Yes响应，表示事物可以执行；如果参与者没有成功执行事物，那么就反馈给协调者No响应，表示事物不可以执行

**阶段二：执行事物提交**

在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事物提交操作，正常情况下，包含以下两种可能：

*执行事物的提交*

假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事物的提交。

1、发送提交亲求

协调者向所有参与者节点发送Commit请求

2、事物提交

参与者接收到Commit请求之后，会正式执行事物的提交操作，并在完成提交之后释放在整个事物执行期间占用的事物资源

3、反馈事物提交结果

参与者在完成事物的提交之后，向协调者发送Ack消息

4、完成事物

协调者接收到所有参与者反馈的Ack消息后，完成事物

*中断事物*

假如任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者尚无法接收到所有参与者的响应结果，那么就会中断事物

1、发送回滚请求

协调者向所有参与者节点发送Rollback请求

2、事物回滚

参与者接收到Rollback请求之后，会利用其在阶段一中记录的Undo信息来执行事物的回滚操作，并在完成回滚操作后释放在整个事物执行期间占用的资源

3、反馈事物的提交结果

参与者在完成事物的回滚后，会向协调者发送Ack消息

4、中断事物

协调者接收到所有的参与者反馈的Ack消息后，完成事物中断

**优缺点：**

1、优点：原理简单、实现方便

2、缺点：同步阻塞、单点问题、脑裂（数据不一致）、太过保守

其流程图如下：
![两阶段提交流程图](../pictures/两阶段提交流程图.png)

注：黄色代表参与者，蓝色代表协调者

# 二、三阶段提交（3PC）

三阶段提交，是二阶段提交的改进版，即将二阶段提交协议的“提交事物请求”过程一分为二，形成了由CanCommit、PreCommit、doCommit三个阶段组成的事物处理协议

**阶段一：CanCommit**

1、事物询问

协调者向所有的参与者发送一个包含事物内容的canCommit请求，询问是否可以执行事物提交操作，并开始等待各参与者的响应

2、各参与者向协调者反馈事物询问的响应

参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事物，那么会反馈Yes响应，并进入预备状态，否则反馈No响应

**阶段二：PreCommit**

在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事物的PreCommit操作，正常情况下包含两种可能：

假如事物的协调者从所有的参与者获得到的反馈都是Yes，那么会执行预提交

1、发送于提交请求

协调者向所有的参与者节点发送PreCommit请求，并进入Prepared状态

2、事物预提交

参与者接收到PreCommit请求后，会执行事物操作，并将Undo和Redo信息记录到事物日志中

3、各参与者向协调者反馈事物执行的响应

如果参与者成功执行了事物的操作，那么就会反馈给协调者Ack响应，同时等待最终的命令：提交或终止

假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事物

1、发送中断请求

协调者向所有参与者节点发送abort请求

2、中断事物

无论是收到来自协调者的abort请求，还是在等待协调者请求过程中出现超时，参与者都会中断事物

**阶段三：doCommit**

该阶段将进行真正的事物提交，会存在两种可能：

执行提交

1、发送提交请求

进入此阶段，说明事物的协调者收到了所有参与者的Yes响应，那么它的状态将从预提交状态变为提交状态，并向所有的参与者发送docommit请求

2、事物提交

参与者在接收到docommit请求后，会正式执行事物的提交操作，并在完成之后释放整个事物的执行期间占用的事物资源

3、反馈事物的提交结果

参与者在完成事物的提交操作后，会向协调者发送Ack消息

4、完成事物

协调者在接收到所有事物的Ack消息后，完成事物

中断事物

进入这一阶段，假设协调者处于正常的工作状态，并且任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么会中断事物

1、发送中断请求

协调者向所有的参与者发送abort请求

2、事物回滚

参与者在接收到协调者发送的abort请求之后，会利用其在阶段二中记录的Undo信息来执行事物的回滚操作，并在完成回滚之后释放整个事物执行期间所占用的资源

3、反馈事物的回滚结果

参与者在完成事物的回滚操作之后，会向协调者发送Ack消息

4、中断事物

协调者在接收到所有的参与者的Ack消息后，中断事物

**优缺点：**

1、优点：相比于二阶段提交，就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致

2、缺点：参与者接收到协调者的preCommit消息后，如果出现网络分区，可能会出现数据的不一致性

**三阶段提交流程图如下：**![image-20180816004423384](../pictures/三阶段提交流程图.png)

注：黄色代表参与者，蓝色代表协调者

# 二、Paxos算法

## 1、paxos算法的陈述：

**prepare请求：**

Proposer选择一个新的提案编号M~n~，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应：

- 向Proposer承诺，保证不再批准任何编号小于M~n~的提案
- 如果Acceptor已经批准过任何提案，那么其就向Proposer反馈当前该Acceptor已经批准的编号小于M~n~但为最大编号的那个提案的值

**阶段一：**

1、Proposer选择一个提案编号为M~n~，然后向Acceptor的某个超过半数的子集成员发送编号为M~n~的Prepare请求

2、如果一个Acceptor收到一个编号为M~n~的Prepare请求，且编号M~n~大于该Acceptor已经响应的所有Prepare请求的编号，那么他就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M~n~的提案

**阶段二：**

1、如果Proposer收到来自**半数以上的Acceptor**对于其发出的编号为M~n~的Prepare请求的响应，那么它就会发送一个针对[M~n~,V~n~]提案的Accept请求给Acceptor。注意，V~n~的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么他就是任意值

2、如果Acceptor收到这个针对[M~n~,V~n~]提案的Accept请求，只要该Acceptor尚未对编号大于M~n~的Prepare请求作出响应，它就可以通过这个提案

## 2、通过选取主Proposer保证算法的活性

为了保证Paxos算法流程的可持续性，以避免陷入死循环，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案



