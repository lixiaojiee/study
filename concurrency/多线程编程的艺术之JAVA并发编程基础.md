# 一、为什么要使用多线程

1、更多的处理器核心，因为一个处理器核心只能执行一个线程，因此多线程技术可以提高多处理器核心的处理效率

2、更快的响应时间，缩短业务的响应时间，提升了用户体验

3、更好的编程模型

# 二、线程的状态

java线程在运行的声明周期中可能处于下列6种不同的状态；

| 状态名称     | 说明                                                         | 触发                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              | 创建                                                         |
| RUNNABLE     | 运行状态，java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中” | strat()                                                      |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   | 等待其他线程释放监视器锁                                     |
| WAITING      | 进入该状态表示当前线程需要等待其他线程作出一些特定动作（通知或中断），当执行wait()方法时，进入该状态 | Object.wait()、Object.join()、LockSupport.park()             |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 | Thread.sleep(long)、Object.wait(long)、Thread.join(long)、LockSupport.parkNanos()、LockSupport.parkUntil() |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           | 程序执行完成                                                 |

# 三、Daemon线程

daemon线程是一种支持型线程，因为它主要被用做程序中后台调度以及支持型工作。

当java虚拟机中不存在daemon线程的时候，java虚拟机将会退出

daemon线程需要在线程启动前设置，不能在启动线程后设置

在构建daemon线程时，不能依靠finally快中的内容来确保执行关闭或者清理资源的逻辑，因为finally块不会被执行（这条需要查证为什么）。

# 四、启动和终止线程

## 1、中断

中断可以理解为线程的一个标示位属性，它表示一个运行中的线程是否被其它线程进行了中断操作

## 2、过期的suspend()、resume()、stop()

这三个方法分别表示暂停、恢复、停止，现在已经标示为过期，不建议使用的原因为：

以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引起死锁问题

## 3、安全地终止线程

1）使用中断

2）可以利用boolean变量来控制是否需要停止任务并终止该线程

以上两种方式可以使线程有机会去清理资源，是一种比较安全且优雅的终止线程的方式

# 五、线程间的通信

## 1、synchronized

任意线程对Object（Object由synchronized保护）的访问，首先要获取Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试获取监视器锁。

## 2、等待/通知机制

等待/通知机制，是指线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。

等待/通知的相关方法：

| 方法名称       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| notify()       | 通知一个在对象上等待的线程使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁 |
| notifyAll()    | 通知所有等待在该对象上的线程                                 |
| wait()         | 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或者被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁 |
| wait(long)     | 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 |
| wait(long,int) | 对于超时时间更细粒度的控制，可以达到纳秒                     |

调用wait()、notify()、notifyAll()时需要注意以下细节：

1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁

2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列

3）notify()和notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回

4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED

5==）从wait()方法返回的前提是获得了调用对象的锁==

## 3、管道输入/输出流

管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于咸亨之间的数据传输，而传输的媒介为内存。

对于Piped类型的流，必须先进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。

## 4、Thread.join()的使用

如果一个线程执行了Thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和joinjoin(long mills,int nanos)两个具备超时特性的方法。这两个方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。

## 5、线程应用实例

1）线程池的实现原理：

线程池的本质就是使用了一个线程安全的工作队列连接工作着线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作着线程会被唤醒。

2）连接池技术
